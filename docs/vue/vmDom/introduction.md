# 虚拟DOM简介

Vue.js 引入虚拟 DOM，比 Vue.js 1.0 的初始渲染速度提升 2-4 倍，并大大降低了内存的消耗。

现在我们使用的三大主流框架 Vue.js、Angular、React 都是声明式操作 DOM。我们通过描述状态和 DOM 之间的映射关系，将状态渲染成视图。关于状态与视图的转换过程，框架帮我们做，不需要手动去操作 DOM。

每当状态发生变化时，视图都需要重新渲染。如何确定状态中发生了什么变化以及需要在哪里更新 DOM？在这种情况下，最简单粗暴的方式，即不需要关心状态发生了什么变化，也不需要关心在哪里更新 DOM，只需要把所有 DOM 删掉，然后使用状态重新生成一份新的 DOM，并将其输出到页面上显示出来。

但是访问 DOM 是非常昂贵的。如何按上面方式，会造成相当多的性能浪费。状态变化通常只有有限的几个节点需要重新渲染，所以我们不仅需要找出哪里需要更新，还尽量少的访问 DOM。这个问题有很多中解决方案。目前各大框架都有自己的解决方案，在 Angular 中使用脏检查流程，React 中使用虚拟 DOM，Vue1.0 通过细颗粒度绑定。

虚拟 DOM 的解决方案是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。在渲染之前，会使用新生成的虚拟节点树和上一次生成的虚拟节点树进行对比，只渲染不同的部分。

在实际上，Angular 和 React 的变化侦测有一个共同点，那就是它们不知道哪些状态发生了变化。因此，就需要进行比较暴力的对比，React 是通过虚拟 DOM 的对比，Angular 使用脏检查的流程。Vue 的变化侦测和它们都不一样，在一定程度上知道具体哪些状态发生了变化，这样可以通过更细颗粒度的绑定更新视图。也就是说，在 Vue.js,当状态发生了变化时，它在一定程度上知道哪些节点使用了这个节点，从而对这些节点进行更新操作，根本不需要对比。Vue.js 1.0 就是这样实现的。

但是这样做会有一定的代价，颗粒度太细，每个绑定都有一个对于的 Watcher 来观察状态的变化，这样就会有一些内存的开销以及依赖追踪的开销，所以 Vue.js 2.0 采取了一个中等颗粒度的解决方案，状态侦测不再细化到具体的某个节点，而是某个组件，组件内部通过虚拟 DOM 来渲染视图，这样可以大大减少依赖数量和 Watcher 数量。

Vue.js 通过模版来描述状态与视图之间的关系，所以它会先将模版编译成渲染函数，然后执行渲染函数生成虚拟节点，最后使用虚拟节点更新视图。

<img style="text-align: center"  src="https://pic-1254114567.cos.ap-shanghai.myqcloud.com/blog/vue/vue%E6%A8%A1%E7%89%88%E8%BD%AC%E5%8C%96%E8%A7%86%E5%9B%BE%E8%BF%87%E7%A8%8B.png" ><p style="text-align: center">模版转换成视图的过程</p></img>

因此，虚拟 DOM 在 Vue.js 中所做的是提高虚拟节点 VNode 和新旧两个 VNode 进行对比，并根据对比结果进行 DOM 操作来更新视图。

<img src="https://pic-1254114567.cos.ap-shanghai.myqcloud.com/blog/vue/vue%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" ><p style="text-align: center">虚拟 DOM 的执行流程</p></img>
